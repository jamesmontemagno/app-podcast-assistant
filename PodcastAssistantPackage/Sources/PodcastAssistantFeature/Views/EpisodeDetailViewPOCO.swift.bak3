import SwiftUI
import AppKit
import UniformTypeIdentifiers

/// Episode detail view with segmented control for different sections (POCO-based)
public struct EpisodeDetailViewPOCO: View {
    let episode: EpisodePOCO
    let podcast: PodcastPOCO
    let store: PodcastLibraryStore
    
    @State private var selectedSection: EpisodeSection = .details
    @State private var hasUnsavedChanges: Bool = false
    @State private var detailsViewModel: DetailsViewModel?
    @State private var showingTranslation: Bool = false
    @State private var showingTranscriptTranslation: Bool = false
    @State private var transcriptInputText: String = ""
    @State private var transcriptOutputText: String = ""
    
    public init(episode: EpisodePOCO, podcast: PodcastPOCO, store: PodcastLibraryStore) {
        self.episode = episode
        self.podcast = podcast
        self.store = store
    }
    
    public var body: some View {
        VStack(spacing: 0) {
            // Header with episode title
            VStack(alignment: .leading, spacing: 4) {
                Text(episode.title)
                    .font(.title2)
                    .fontWeight(.bold)
                Text("Episode #\(episode.episodeNumber)")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding()
            .background(Color(NSColor.controlBackgroundColor))
            
            Divider()
            
            // Segmented control
            Picker("Section", selection: $selectedSection) {
                Text("Details").tag(EpisodeSection.details)
                Text("Transcript").tag(EpisodeSection.transcript)
                Text("Thumbnail").tag(EpisodeSection.thumbnail)
                Text("AI Ideas").tag(EpisodeSection.aiIdeas)
            }
            .pickerStyle(.segmented)
            .padding()
            
            Divider()
            
            // Content area
            Group {
                switch selectedSection {
                case .details:
                    DetailsSection(
                        episode: episode,
                        podcast: podcast,
                        store: store,
                        hasUnsavedChanges: $hasUnsavedChanges,
                        viewModel: $detailsViewModel
                    )
                case .transcript:
                    TranscriptSection(
                        episode: episode,
                        store: store,
                        showingTranslation: $showingTranscriptTranslation,
                        inputText: $transcriptInputText,
                        outputText: $transcriptOutputText
                    )
                case .thumbnail:
                    PlaceholderSection(title: "Thumbnail", icon: "photo")
                case .aiIdeas:
                    PlaceholderSection(title: "AI Ideas", icon: "sparkles")
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
        .focusedValue(\.selectedEpisodeSection, selectedSection)
        .focusedValue(\.episodeDetailActions, EpisodeDetailActions(
            save: { detailsViewModel?.save() },
            revert: { detailsViewModel?.revert() },
            translate: { showingTranslation = true }
        ))
        .toolbar {
            // Details tab toolbar
            if selectedSection == .details {
                // First group: Translate button
                if #available(macOS 26.0, *) {
                    ToolbarItem(placement: .automatic) {
                        Button {
                            showingTranslation = true
                        } label: {
                            Label("Translate", systemImage: "globe")
                        }
                        .help("Translate episode metadata")
                    }
                }
                
                // Second group: Save/Revert buttons (when dirty)
                if hasUnsavedChanges {
                    ToolbarItemGroup(placement: .automatic) {
                        Button {
                            detailsViewModel?.revert()
                        } label: {
                            Label("Revert", systemImage: "arrow.uturn.backward")
                        }
                        .help("Discard unsaved changes")
                        
                        Button {
                            detailsViewModel?.save()
                        } label: {
                            Label("Save", systemImage: "checkmark")
                        }
                        .keyboardShortcut("s", modifiers: .command)
                        .help("Save changes (âŒ˜S)")
                    }
                }
            }
            
            // Transcript tab toolbar
            if selectedSection == .transcript {
                // Group 1: Import
                ToolbarItem(placement: .automatic) {
                    Button {
                        importTranscriptFile()
                    } label: {
                        Label("Import", systemImage: "square.and.arrow.down")
                    }
                    .help("Import transcript file")
                }
                
                // Group 2: Convert, Export, Clear
                ToolbarItemGroup(placement: .automatic) {
                    Button {
                        convertTranscriptToSRT()
                    } label: {
                        Label("Convert", systemImage: "arrow.triangle.2.circlepath")
                    }
                    .help("Convert to SRT format")
                    .disabled(transcriptInputText.isEmpty)
                    
                    Button {
                        exportTranscriptFile()
                    } label: {
                        Label("Export", systemImage: "square.and.arrow.up")
                    }
                    .help("Export SRT file")
                    .disabled(transcriptOutputText.isEmpty)
                    
                    Button {
                        clearTranscriptAll()
                    } label: {
                        Label("Clear", systemImage: "trash")
                    }
                    .help("Clear all transcript data")
                }
                
                // Group 3: Translate
                if #available(macOS 26.0, *) {
                    ToolbarItem(placement: .automatic) {
                        Button {
                            showingTranscriptTranslation = true
                        } label: {
                            Label("Translate", systemImage: "globe")
                        }
                        .help("Translate transcript")
                        .disabled(transcriptOutputText.isEmpty)
                    }
                }
            }
        }
        .sheet(isPresented: $showingTranslation) {
            if #available(macOS 26.0, *) {
                TranslationSheet(
                    title: episode.title,
                    description: episode.episodeDescription ?? ""
                )
            }
        }
        .sheet(isPresented: $showingTranscriptTranslation) {
            if #available(macOS 26.0, *) {
                TranscriptTranslationSheet(srtText: transcriptOutputText)
            }
        }
    }
    
    // MARK: - Transcript Helper Functions
    
    private func importTranscriptFile() {
        let panel = NSOpenPanel()
        panel.allowedContentTypes = [.plainText, .text]
        panel.allowsMultipleSelection = false
        
        panel.begin { response in
            if response == .OK, let url = panel.url {
                do {
                    let content = try String(contentsOf: url, encoding: .utf8)
                    transcriptInputText = content
                    episode.transcriptInputText = content
                } catch {
                    print("Failed to import file: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func convertTranscriptToSRT() {
        guard !transcriptInputText.isEmpty else { return }
        
        do {
            let converter = TranscriptConverter()
            let srtOutput = try converter.convertToSRT(from: transcriptInputText)
            transcriptOutputText = srtOutput
            episode.srtOutputText = srtOutput
        } catch {
            print("Conversion error: \(error.localizedDescription)")
        }
    }
    
    private func exportTranscriptFile() {
        guard !transcriptOutputText.isEmpty else { return }
        
        let panel = NSSavePanel()
        if let srtType = UTType(filenameExtension: "srt") {
            panel.allowedContentTypes = [srtType]
        } else {
            panel.allowedContentTypes = [.plainText]
        }
        panel.nameFieldStringValue = "\(episode.title).srt"
        panel.canCreateDirectories = true
        
        panel.begin { response in
            if response == .OK, let url = panel.url {
                do {
                    try transcriptOutputText.write(to: url, atomically: true, encoding: .utf8)
                } catch {
                    print("Failed to export file: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func clearTranscriptAll() {
        transcriptInputText = ""
        transcriptOutputText = ""
        episode.transcriptInputText = nil
        episode.srtOutputText = nil
    }
}

// MARK: - Detail Sections

// Removed - now using EpisodeSection from MenuActions.swift

// MARK: - Details Section

// Simple class to expose save/revert methods to parent
class DetailsViewModel {
    var save: () -> Void = {}
    var revert: () -> Void = {}
}

private struct DetailsSection: View {
    let episode: EpisodePOCO
    let podcast: PodcastPOCO
    let store: PodcastLibraryStore
    @Binding var hasUnsavedChanges: Bool
    @Binding var viewModel: DetailsViewModel?
    
    @State private var title: String = ""
    @State private var episodeNumber: String = ""
    @State private var description: String = ""
    @State private var publishDate: Date = Date()
    @State private var showingSaveConfirmation: Bool = false
    @State private var isInitialLoad: Bool = true
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                // Episode Title
                VStack(alignment: .leading, spacing: 8) {
                    Label("Episode Title", systemImage: "textformat")
                        .font(.headline)
                    
                        TextField("Enter episode title", text: $title, axis: .vertical)
                        .textFieldStyle(.roundedBorder)
                        .lineLimit(2...4)
                        .onChange(of: title) { oldValue, newValue in
                            if isInitialLoad { return }
                            hasUnsavedChanges = true
                        }
                }
                
                Divider()
                
                // Episode Number
                VStack(alignment: .leading, spacing: 8) {
                    Label("Episode Number", systemImage: "number")
                        .font(.headline)
                    
                    HStack {
                        TextField("Number", text: $episodeNumber)
                            .textFieldStyle(.roundedBorder)
                            .frame(width: 100)
                            .onChange(of: episodeNumber) { _, _ in
                                if isInitialLoad { return }
                                hasUnsavedChanges = true
                            }
                        
                        Spacer()
                    }
                }
                
                Divider()
                
                // Release Date
                VStack(alignment: .leading, spacing: 8) {
                    Label("Release Date", systemImage: "calendar")
                        .font(.headline)
                    
                    DatePicker("Release Date", selection: $publishDate, displayedComponents: [.date])
                        .datePickerStyle(.compact)
                        .labelsHidden()
                        .onChange(of: publishDate) { _, _ in
                            if isInitialLoad { return }
                            hasUnsavedChanges = true
                        }
                }
                
                Divider()
                
                // Episode Description
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Label("Description", systemImage: "doc.text")
                            .font(.headline)
                        
                        Spacer()
                        
                        if !description.isEmpty {
                            HStack(spacing: 4) {
                                Image(systemName: "checkmark.circle.fill")
                                    .foregroundStyle(.green)
                                Text("\(description.split(separator: " ").count) words")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                        }
                    }
                    
                    TextEditor(text: $description)
                        .font(.body)
                        .frame(minHeight: 200)
                        .scrollContentBackground(.hidden)
                        .background(Color(NSColor.textBackgroundColor))
                        .cornerRadius(6)
                        .overlay(
                            RoundedRectangle(cornerRadius: 6)
                                .stroke(Color(NSColor.separatorColor), lineWidth: 1)
                        )
                        .onChange(of: description) { _, _ in
                            if isInitialLoad { return }
                            hasUnsavedChanges = true
                        }
                    
                    if description.isEmpty {
                        Text("Add a description for this episode. You can also generate one using AI Ideas.")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }
                
                Divider()
                
                // Podcast Association
                VStack(alignment: .leading, spacing: 8) {
                    Label("Podcast", systemImage: "mic")
                        .font(.headline)
                    
                    HStack(spacing: 12) {
                        if let artworkData = podcast.artworkData,
                           let image = ImageUtilities.loadImage(from: artworkData) {
                            Image(nsImage: image)
                                .resizable()
                                .scaledToFit()
                                .frame(width: 60, height: 60)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                        }
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text(podcast.name)
                                .font(.body)
                                .fontWeight(.medium)
                            
                            if let podcastDescription = podcast.podcastDescription {
                                Text(podcastDescription)
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                    .lineLimit(2)
                            }
                        }
                    }
                    .padding(12)
                    .background(Color(NSColor.controlBackgroundColor))
                    .cornerRadius(8)
                }
                
                Divider()
                
                // Metadata
                VStack(alignment: .leading, spacing: 8) {
                    Label("Metadata", systemImage: "info.circle")
                        .font(.headline)
                    
                    VStack(alignment: .leading, spacing: 6) {
                        HStack {
                            Text("Created:")
                                .foregroundStyle(.secondary)
                            Text(episode.createdAt, style: .date)
                            Text(episode.createdAt, style: .time)
                        }
                        .font(.caption)
                        
                        HStack {
                            Text("Has Transcript:")
                                .foregroundStyle(.secondary)
                            Image(systemName: episode.hasTranscriptData ? "checkmark.circle.fill" : "xmark.circle")
                                .foregroundStyle(episode.hasTranscriptData ? .green : .secondary)
                        }
                        .font(.caption)
                        
                        HStack {
                            Text("Has Thumbnail:")
                                .foregroundStyle(.secondary)
                            Image(systemName: episode.hasThumbnailOutput ? "checkmark.circle.fill" : "xmark.circle")
                                .foregroundStyle(episode.hasThumbnailOutput ? .green : .secondary)
                        }
                        .font(.caption)
                        
                        HStack {
                            Text("Has AI Description:")
                                .foregroundStyle(.secondary)
                            Image(systemName: episode.episodeDescription != nil ? "checkmark.circle.fill" : "xmark.circle")
                                .foregroundStyle(episode.episodeDescription != nil ? .green : .secondary)
                        }
                        .font(.caption)
                    }
                    .padding(12)
                    .background(Color(NSColor.controlBackgroundColor))
                    .cornerRadius(8)
                }
                
                // Save confirmation
                if showingSaveConfirmation {
                    HStack(spacing: 8) {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundStyle(.green)
                        Text("Changes saved successfully")
                            .font(.subheadline)
                    }
                    .padding(12)
                    .frame(maxWidth: .infinity)
                    .background(Color.green.opacity(0.1))
                    .cornerRadius(8)
                }
            }
            .padding()
        }
        .onAppear {
            loadEpisodeData()
            
            // Register save/revert handlers with parent
            let vm = DetailsViewModel()
            vm.save = saveChanges
            vm.revert = revertChanges
            viewModel = vm
        }
    }
    
    // MARK: - Data Management
    
    private func loadEpisodeData() {
        isInitialLoad = true
        title = episode.title
        episodeNumber = "\(episode.episodeNumber)"
        description = episode.episodeDescription ?? ""
        publishDate = episode.publishDate
        hasUnsavedChanges = false
        
        // Small delay to ensure state is settled before tracking changes
        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(100))
            isInitialLoad = false
        }
    }
    
    func saveChanges() {
        let trimmedTitle = title.trimmingCharacters(in: .whitespaces)
        guard !trimmedTitle.isEmpty else { return }
        
        guard let number = Int32(episodeNumber) else {
            return
        }
        
        // Update episode (it's a class, so we can modify directly)
        episode.title = trimmedTitle
        episode.episodeNumber = number
        episode.episodeDescription = description.isEmpty ? nil : description
        episode.publishDate = publishDate
        
        do {
            try store.updateEpisode(episode)
            hasUnsavedChanges = false
            
            // Show save confirmation
            showingSaveConfirmation = true
            Task { @MainActor in
                try? await Task.sleep(for: .seconds(2))
                showingSaveConfirmation = false
            }
        } catch {
            print("Error saving episode: \(error)")
        }
    }
    
    func revertChanges() {
        loadEpisodeData()
    }
}

// MARK: - Transcript Section

private struct TranscriptSection: View {
    let episode: EpisodePOCO
    let store: PodcastLibraryStore
    @Binding var showingTranslation: Bool
    @Binding var inputText: String
    @Binding var outputText: String
    
    @State private var isProcessing: Bool = false
    @State private var errorMessage: String?
    @State private var successMessage: String?
    
    private let converter = TranscriptConverter()
    
    var body: some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                // Left pane: Input
                VStack(alignment: .leading, spacing: 8) {
                    Text("Input Transcript")
                        .font(.headline)
                        .padding(.horizontal)
                        .padding(.top)
                    
                    ScrollView {
                        TextEditor(text: $inputText)
                            .font(.system(.body, design: .monospaced))
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .onChange(of: inputText) { _, newValue in
                                episode.transcriptInputText = newValue.isEmpty ? nil : newValue
                            }
                    }
                    .background(Color(nsColor: .textBackgroundColor))
                }
                .frame(width: geometry.size.width / 2)
                
                Divider()
                
                // Right pane: Output
                VStack(alignment: .leading, spacing: 8) {
                    Text("SRT Output")
                        .font(.headline)
                        .padding(.horizontal)
                        .padding(.top)
                    
                    ScrollView {
                        TextEditor(text: $outputText)
                            .font(.system(.body, design: .monospaced))
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    }
                    .background(Color(nsColor: .textBackgroundColor))
                }
                .frame(width: geometry.size.width / 2)
            }
        }
        .onAppear {
            inputText = episode.transcriptInputText ?? ""
            outputText = episode.srtOutputText ?? ""
        }
    }
}

// MARK: - Placeholder Section
                    
        successMessage = "Transcript cleared"
        Task { @MainActor in
            try? await Task.sleep(for: .seconds(2))
            successMessage = nil
        }
    }
}

// MARK: - Placeholder Section

private struct PlaceholderSection: View {
    let title: String
    let icon: String
    
    var body: some View {
        ContentUnavailableView(
            title,
            systemImage: icon,
            description: Text("This section is coming soon")
        )
    }
}

// MARK: - Translation Sheet

@available(macOS 26.0, *)
private struct TranslationSheet: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = EpisodeTranslationViewModel()
    
    let title: String
    let description: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header
            HStack {
                Image(systemName: "globe")
                    .foregroundColor(.blue)
                    .font(.title2)
                Text("Translate Episode")
                    .font(.title2)
                    .fontWeight(.semibold)
                Spacer()
                Button("Done") {
                    dismiss()
                }
                .keyboardShortcut(.cancelAction)
            }
            
            Divider()
            
            // Language selection
            VStack(alignment: .leading, spacing: 8) {
                Text("Target Language")
                    .font(.headline)
                
                if viewModel.isLoadingLanguages {
                    ProgressView("Loading languages...")
                        .frame(maxWidth: .infinity, alignment: .leading)
                } else if viewModel.availableLanguages.isEmpty {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("No translation languages available")
                            .foregroundStyle(.secondary)
                        Text("Install translation packs in System Settings > General > Language & Region > Translation Languages")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                } else {
                    Picker("Language", selection: $viewModel.selectedLanguage) {
                        ForEach(viewModel.availableLanguages) { language in
                            HStack {
                                Text(language.localizedName)
                                if language.isInstalled {
                                    Image(systemName: "checkmark.circle.fill")
                                        .foregroundStyle(.green)
                                } else {
                                    Image(systemName: "arrow.down.circle")
                                        .foregroundStyle(.orange)
                                }
                            }
                            .tag(language as AvailableLanguage?)
                        }
                    }
                    .labelsHidden()
                }
                
                if let language = viewModel.selectedLanguage, !language.isInstalled {
                    HStack(spacing: 8) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .foregroundStyle(.orange)
                        Text("Language pack not installed. Download it from System Settings.")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                    .padding(8)
                    .background(Color.orange.opacity(0.1))
                    .cornerRadius(6)
                }
            }
            
            Divider()
            
            // Translate button
            HStack {
                Spacer()
                Button {
                    Task {
                        await viewModel.translateEpisode(title: title, description: description)
                    }
                } label: {
                    if viewModel.isTranslating {
                        ProgressView()
                            .controlSize(.small)
                            .padding(.trailing, 4)
                        Text("Translating...")
                    } else {
                        Text("Translate")
                    }
                }
                .buttonStyle(.borderedProminent)
                .disabled(viewModel.isTranslating || viewModel.selectedLanguage == nil || viewModel.selectedLanguage?.isInstalled == false)
            }
            
            Divider()
            
            // Results
            if !viewModel.translatedTitle.isEmpty || !viewModel.translatedDescription.isEmpty {
                ScrollView {
                    VStack(alignment: .leading, spacing: 16) {
                        // Translated title
                        VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Translated Title")
                                    .font(.headline)
                                Spacer()
                                Button {
                                    copyToClipboard(viewModel.translatedTitle)
                                } label: {
                                    Label("Copy", systemImage: "doc.on.doc")
                                }
                                .buttonStyle(.bordered)
                                .disabled(viewModel.translatedTitle.isEmpty)
                            }
                            
                            if viewModel.translatedTitle.isEmpty {
                                Text("No title translated")
                                    .foregroundStyle(.secondary)
                                    .padding(12)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color(NSColor.controlBackgroundColor))
                                    .cornerRadius(6)
                            } else {
                                Text(viewModel.translatedTitle)
                                    .textSelection(.enabled)
                                    .padding(12)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color(NSColor.controlBackgroundColor))
                                    .cornerRadius(6)
                            }
                        }
                        
                        // Translated description
                        VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Translated Description")
                                    .font(.headline)
                                Spacer()
                                Button {
                                    copyToClipboard(viewModel.translatedDescription)
                                } label: {
                                    Label("Copy", systemImage: "doc.on.doc")
                                }
                                .buttonStyle(.bordered)
                                .disabled(viewModel.translatedDescription.isEmpty)
                            }
                            
                            if viewModel.translatedDescription.isEmpty {
                                Text("No description translated")
                                    .foregroundStyle(.secondary)
                                    .padding(12)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color(NSColor.controlBackgroundColor))
                                    .cornerRadius(6)
                            } else {
                                Text(viewModel.translatedDescription)
                                    .textSelection(.enabled)
                                    .padding(12)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color(NSColor.controlBackgroundColor))
                                    .cornerRadius(6)
                            }
                        }
                    }
                }
                .frame(maxHeight: 300)
            }
            
            // Error message
            if let error = viewModel.errorMessage {
                HStack(spacing: 8) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundStyle(.red)
                    Text(error)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                .padding(12)
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.red.opacity(0.1))
                .cornerRadius(6)
            }
            
            Spacer()
        }
        .padding(24)
        .frame(width: 600, height: 500)
    }
    
    private func copyToClipboard(_ text: String) {
        guard !text.isEmpty else { return }
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(text, forType: .string)
    }
}
